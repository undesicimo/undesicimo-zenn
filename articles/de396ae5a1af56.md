---
title: "React Compilerを深掘りしよう"
emoji: "😸"
type: "tech"
topics: ["react", "javascipt"]
published: false
---

# はじめに

React では、コンポーネント内で定義している関数・変数も新しく生成されてしまい、値が変わっていなかったとしても再計算されてしまいます。再精算を防ぐために、該当する関数や引数を`useMemo` `useCallback` `React.memo`などをいちいち囲んで、実装者がメモ化する必要がありました。

## 今まで

### 関数の再精算を防ぐためのパターン

```typescript
const UseMemoExample = () => {
  const [count, setCount] = useState(0);

  const doubledCount = useMemo(() => {
    return count * 2;
  }, [count]); // countの値が変わっていない限り、再精算しない

  return (
    <div>
      <h1>useMemo Example</h1>
      <button onClick={() => setCount(count + 1)}>Increment Count</button>
      <p>Count: {count}</p>
      <p>Doubled Count: {doubledCount}</p>
    </div>
  );
};
```

再処理させないために引数を`useMemo`に囲みます

---

### コンポーネントの再レンダリングを防ぐパターン

```ts
export default function App() {
  const [count, setCount] = useState(0);
  return (
    <div className='card'>
      <button onClick={() => setCount(count => count + 1)}>Click me</button>
      <p>count is {count}</p>
      <HeavyComponent />
    </div>
  );
}

function HeavyComponent() {
  return (
    <div>
      <h1>Heavy Component</h1>
    </div>
  );
}
```

`Heavy Component`の再レンダリングを防ぐために、`React.Memo`に囲みます

```ts
export default function App() {
  const [count, setCount] = useState(0);
  return (
    <div className='card'>
      <button onClick={() => setCount(count => count + 1)}>Click me</button>
      <p>count is {count}</p>
      <MemoizedHeavyComponent />
    </div>
  );
}

const MemoizedHeavyComponent = React.memo(HeavyComponent); //メモ化する

function HeavyComponent() {
  return (
    <div>
      <h1>Heavy Component</h1>
    </div>
  );
}
```

今までは`とりあえずメモ化`していたという実感はありますでしょうか？
軽い処理に対してメモ化すると、キャッシュを参照するオーバーヘッドが発生します。

React Compiler は、書いた**React のコード**を単にメモ化をしてくれるのみではなく、あらゆるな仕組みで最適化してくれます

React Compiler の機能を理解するには、まずは JSX のコードをどういった形でトランスパイルされるのかを理解する必要があります

以下のようにシンプルな React コンポーネントがあるとします。

```js
export default function App() {
  const message = "Hello world";
  return <div className='card'>{message}</div>;
}
```

React Compiler 以前、上記のカウンターコンポーネントをトランスパイルすると以下のようになります

```js
export default function App() {
  const message = "Hello world";
  return _jsx("div", {
    className: "card",
    children: message,
  });
}
```

トランスパイルされたコードには、この関数が呼び出されるたびに(再レンダリング)、`_jsx`が実行され、コンポーネント作成処理が行われます。
再処理するたびに、同じ関数が実行されるようになっています。

React Compiler でコンパイルすると以下の通りになります

```js
function App() {
  const $ = _c(1);

  let t0;

  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div className='card'>{"Hello world"}</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }

  return t0;
}
```

### 重要ポイントとなる挙動

```js
const $ = _c(1);
```

- `_c()`の関数は、React19 の新しいフック `useMemoCache` に該当します ([参照](https://github.com/facebook/react/blob/ea6e05912aa43a0bbfbee381752caa1817a41a86/packages/react-server/src/ReactFlightHooks.js#L84-L92))
  - `1`という引数は、メモ化対象の要素の数です。
  - 要素の数の長さ(1)がある`REACT_MEMO_CACHE_SENTINEL`の配列を返します。

```js
if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
  t0 = <div className='card'>{"Hello world"}</div>;
  $[0] = t0;
} else {
  t0 = $[0];
}
```

- 該当コンポーネントが初期値として設定されます。👉 `$[0] = t0`

  - ２回目以降、メモ化されたコンポーネントを返します。

  :::message
  `React.memo`が行うメモ化と似た処理になります。
  :::

- `children`の prop を見てみると、`message`は**定数なので**、`const`の定義なくなり、そのまま文字列を渡すようにしています。これは React Compiler その一つの機能になります。👉 `t0 = <div className='card'>{"Hello world"}</div>`

## 動的値がある時

`onClick`発火による、カウンターがインクリメントされるコンポーネントがあるとします。

```js
import { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

React Compiler 出力

```js
function Counter() {
  const $ = _c(2);

  const [count, setCount] = useState(0);
  let t0;

  if ($[0] !== count) {
    t0 = (
      <div>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
    $[0] = count;
    $[1] = t0;
  } else {
    t0 = $[1];
  }

  return t0;
}
```

- 初回は、コンポーネントと動的値となる`count`を別要素として扱い、それぞれメモ化しています。

  - ２回目以降、`count`が変わっていなければ、メモ化された jsx を返すようになっています。👉 `if ($[0] !== count)`

- `count`が変わっていたら、`count`とともにコンポーネントも再処理されます。
